# Chapter 3: Sequential logic

#### 조합 칩(Combinational chip)
- 입력 값의 조합에만 의존하는 함수를 계산한다.
- **상태를 유지하지 않는다.**
- 불 논리 칩과 산술 칩을 모두 포함한다.

#### 순차 칩(Sequential chip)

<br><br>

배경
---
### 클록(clock)
- **시간 진행을 표현**함
- 0-1 또는 고(high)-저(low), 틱(tick)-톡(tock) 등으로 표시된 두 신호 상태를 연속해서 오가는 발진기(oscillator)로 구현됨
- 현재 클록의 상태(틱 또는 톡)는 **2진 신호로 표현**됨
- 이 신호는 하드웨어 회로망을 통해 컴퓨터에 있는 **모든 순차 칩들에 동시에 전달**됨
- 사이클(cycle): 
  - '틱'의 시작에서 다음번 '톡'의 끝까지 경과된 시간
  - **하나의 시간 단위 구분**을 모델링한 것

<br>

### 플립플롭(flip-flop)
- 이 책에서는 여러 종류의 플립플롭 중에서 **데이터 플립플롭(data flip-flop, DFF)** 를 사용함
- 이 소자의 인터페이스는 **1 비트 데이터 입력과 1 비트 데이터 출력**으로 구성됨
- DFF는 마스터 클록에 따라 계속적으로 바뀌는 클록 입력 신호를 받음
- **out(t) = in(t-1)** 을 수행하게 됨
- 한 마디로 정리하면, **바로 이전 시간의 입력을 출력하는 장치**
- 컴퓨터에서 상태를 유지하는 모든 하드웨어(2진 셀, 레지스터, RAM 등)의 기초

<br>

### 레지스터(register)
- **시간이 지나도 값을 '저장'하고 '로드'할 수 있는 장치**
- **out(t) = out(t-1)**
- **내부 핀의 입력원은 오로지 하나**여야만 한다.
- 멀티플렉서의 '**선택 비트**'는 전체 레지스터의 '**로드 비트(load bit)**'
- **새로운 값 저장**: 입력 in에 새로운 값을 넣고, **로드 비트를 1**로 설정하면 됨
- **기존 값 유지**: **로드비트를 0**으로 설정하면 됨
- 폭(width): 레지스터가 저장할 수 있는 비트의 개수(ex: 16, 32, 64비트)
- 단어(word): 레지스터에 저장되는 멀티비트 값

![image](https://user-images.githubusercontent.com/69896250/147710416-6ae1a1e0-f2eb-4127-97e6-40e4338be0e4.png)

<br>

### 메모리(memory)
**임의 접근 메모리(Random Access Memory, RAM)**
- 레지스터를 여러 개 쌓아 올려서 만듦
- 메모리 내의 어떤 단어든 물리적 **저장 위치와 관계없이 똑같은 속도로 직접 접근이 가능**함
- **읽기 연산(load=0)**: 선택된 레지스터의 값을 바로 출력
- **쓰기 연산(load=1)**: 다음 사이클 때 선택된 메모리 레지스터에서 입력값을 받아, 해당 값을 출력
- 폭(width): 단어의 비트 개수
- 크기(size): RAM 내의 단어 수

<br>

### 계수기(counter)
- **매 시간 단위마다 내부 상태 값을 증가**시키는 순차 칩
- **out(t) = out(t-1)+c** (c는 보통 1)
- ex) 프로그램 계수기(program counter): 다음에 실행해야 할 프로그램 명령의 주소를 출력하는 기능을 함

<br>

### 시간 문제
***조합 칩(combinational chip)***
- **시간을 인지하지 못함**
- 피드백 루프를 넣으면 출력은 입력을, 입력은 출력을 따르므로, 결국 **출력이 자기 자신을 따라 결정**된다는 문제가 발생
- **조합 칩의 출력**은 시간과 무관하게 **입력이 바뀔 때만 변경**됨
- 시간 개념이 없으므로 언제 어떤 데이터 값이 도착하든 계속 값을 더한다.

***순차 칩(sequential chip)***
- 직접적이든 간접적이든 항상 **하나 이상의 DFF 게이트를 장착**한 칩
- **시간 t의 출력은 자기 자신이 아닌 시간 t-1의 출력**을 하기 때문에 조합 칩에 피드백 루프가 있을 때 생기는 **'데이터 경쟁(data race)'를 피할 수 있음**
- **순차 칩의 출력**은 **한 클록 사이클이 넘어갈 때 바뀌며**, 한 사이클 안에서는 바뀌지 않는다.
- **이산화(discretization)**: 순차 칩의 출력이 연속적으로 변하지 않고 **클록 사이클 단위로 변화하는 것**

<br>

명세
---
### 데이터 플립플롭, Data-Flip-Flop, DFF
![image](https://user-images.githubusercontent.com/69896250/148138705-5eccdd85-f3c5-43d7-97e6-0dd2b34f2f1d.png)
```
칩 이름: DFF
입력:    in
출력:    out
기능:    out(t)=in(t-1)
설명:    이 게이트는 이미 내장 버전이 있으므로 구현할 필요가 없다.
```
**어떤 칩이든 DFF 게이트를 집어넣으면, 그 칩뿐 아니라 그 칩에 기반한 모든 상위 계층 칩들에 시간의존성이 생긴다.**<br>
이런 칩들을 순차칩(sequential chip)이라 한다.

- DFF들은 모두 하나의 마스터 클록에 연결되어 **함께 행동**한다.
- **클록 사이클이 시작할 때**, 컴퓨터 내 모든 DFF 출력들은 **전 사이클의 입력에 따라 맞춰진**다.
- **그 외 시간**에는 DFF가 **'잠금(latch)' 상태**가 된다. ```잠금(latch): 입력이 변해도 출력이 곧바로 영향을 받지 않는다```
- 이런 연산이 **매 초당 대략 십억 번씩**(컴퓨터의 클록 주파수에 따라 다름) 시스템 내의 **모든 DFF에서 수행**된다.

<br><br>

### (DFF에 기반한) 레지스터, register
![image](https://user-images.githubusercontent.com/69896250/148139255-998b5277-6d22-4909-9db7-adda12e073f1.png)
```
칩 이름: Bit
입력:    in, load
출력:    out
기능:    If load(t-1) then out(t)=in(t-1)
         else out(t)=out(t-1)
```
- 비트(bit), 또는 2진 셀(binary cell)이라 부르는 1비트 레지스터
- **하나의 정보 비트(0 또는 1)를 저장하도록 설계된 소자**

<br>

![image](https://user-images.githubusercontent.com/69896250/148139713-71a70485-dea0-4495-9513-cb6752ab0281.png)
```
칩 이름: Register
입력:    in[16], load
출력:    out[16]
기능:    If load(t-1) then out(t)=in(t-1)
         else out(t)=out(t-1)
설명:    "="는 16비트 연산이다.
```
- 레지스터는 **입력 핀과 출력 핀이 멀티비트 값을 처리할 수 있다는 점을 제외하고는 기본적으로 2진 셀과 API가 같음**

<br>

- 읽기: 내부 값을 읽으려면 출력 신호를 보면 됨
- 쓰기: 새로운 데이터 값 d를 쓰려면, in에 d를 입력하고, load에 명령 신호(1로 설정)를 주면 됨

<br><br>

### (레지스터에 기반한) 메모리 뱅크, memory bank
![image](https://user-images.githubusercontent.com/69896250/148140724-aace444a-65f4-472a-af8a-fec008220220.png)
```
칩 이름: RAMn    // n과 k 목록은 맨 아래에 있음
입력:    in[16], address[k], load
출력:    out[16]
기능:    out(t)=RAM[address(t)](t)
         If load(t-1) then
           RAM[address(t-1)](t)=in(t-1)
설명:    "="는 16비트 연산이다.
```
- RAM은 **직접 접근(direct-access) 메모리 장치**로, **n개의 w-비트 레지스터를 배열하고 직접 접근 회로를 연결한 소자**다.

<br>

- 읽기: 레지스터 번호 m에 해당하는 주소의 내부 값을 읽으려면, address에 m을 넣는다.
- 쓰기: 새로운 데이터 값 d를 레지스터 번호 m에 해당하는 주소에 쓰려면, address에 m을, in에 d를 입력하고 load 비트를 활성화한다.

<br><br>

### (레지스터에 기반한) 계수기 칩, counter chip
![image](https://user-images.githubusercontent.com/69896250/148140076-1a971933-483f-4cd5-9ec8-fe1c4c3e8bd6.png)
```
칩 이름: PC   // 16비트 카운터
입력:    in[16], inc, load, reset
출력:    out[16]
기능:    If reset(t-1) then out(t)=0
           else if load(t-1) then out(t)=in(t-1)
             else if inc(t-1) then out(t)=out(t-1)+1
               else out(t)=out(t-1)
설명:    "="는 16비트 할당이다.
         "+"는 16비트 산술 연산이다.
```
- 일반적인 상태에서 계수기는 매 클록 사이클마다 단순히 상태 값을 1 증가시켜, 컴퓨터가 프로그램에서 다음번 명려을 불러올 수 있게 해야 한다.
- 하지만 우리는 **로드와 리셋이 가능한 계수기가 필요**하다.

<br>

- inc=1일 때, 계수기는 매 클록 사이클마다 상태 값을 증가시키고, out(t)=out(t-1)+1을 출력한다.
- reset 비트를 활성화하면 계수기가 0으로 재설정된다.
- 계수를 d로 초기화하려면 in에 d를 입력하고 load 비트를 활성화한다.
