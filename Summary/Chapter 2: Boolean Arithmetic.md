# Chapter 1: Boolean Logic

배경
---
#### 2진수
0과 1로 이루어진 수, 10진법과 달리 2진법은 기수(base)를 2로 한다.<br>
ex)
| 10진수 | 2진수 |
| :-: | :-: |
| 1 | 001 |
| 2 | 010 |
| 3 | 011 |
| 4 | 100 |
| 5 | 101 |
| 6 | 110 |
| 7 | 111 |

<br>

#### 2진 덧셈
10진수 덧셈과 마찬가지로 오른쪽에서 왼쪽 자릿수로 숫자들을 하나씩 더하면 된다.<br>
이때 가장 오른쪽 숫자를 **최하위 비트(least significant bit, LSB)** 라고 하고,<br>
가장 왼쪽 숫자를 **최상위 비트(most significant bit, MSB)** 라고 한다.

<br>

최하위비트부터 덧셈을 한 다음 **자리올림 비트(carry bit)**(0 또는 1)를 다음 순서의 비트 쌍의 합에 더한다.<br>
마지막 비트를 더하고 나서도 자리올림 비트가 1이면 **오버플로(overflow)** 가 발생한다.<br>
마지막 비트를 더했을 때 자리올림 비트가 0이면 덧셈이 끝난다.

<br>

한 쌍의 n비트 2진수 덧셈을 구현하려면 3개의 비트(한 쌍의 비트와 자리올림 비트)를 합산하는 논리 게이트를 구성하면 된다.<br>

<br>

#### 2의 보수법
2진수의 부호를 나타내기 위해 오늘날 대부분 컴퓨터에서 사용되는 방법이다.<br>
기수의 보수법(radix complement)이라고도 부른다.
||양수|음수||
|:-:|:-:|:-:|:-:|
|0|0000|||
|1|0001|1111|-1|
|2|0010|1110|-2|
|3|0011|1101|-3|
|4|0100|1100|-4|
|5|0101|1011|-5|
|6|0110|1010|-6|
|7|0111|1001|-7|
|||1000|-8|


```
- 총 2^n개의 부호 있는 숫자를 표현할 수 있다.
- 최댓값과 최솟값은 각각 2^(n-1)과 -2^(n-1)이다.
- 모든 양수 코드는 0으로, 모든 음수 코드는 1로 시작한다.
- 양수를 음수로 바꿀 땐, 양수의 0은 1로, 1은 0으로 바꿔준 뒤 최하위 비트에 1을 더해주면 된다.
- 덧셈을 할 때 양수인지 음수인지 신경쓰지 않아도 오버플로 비트만 버리면 2의 보수로 결과가 나온다.
```

<br>

명세
---
### 가산기
- 반가산기(half-adder): 두 비트를 더한다.
- 전가산기(full-adder): 세 비트를 더한다.
- 가산기(adder): 두 개의 n비트 숫자를 더한다.
- 증분기(incrementer): 주어진 숫자에 1을 더한다.


